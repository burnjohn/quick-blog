---
description: Backend development guidelines for Node.js, Express, and MongoDB in Quick Blog
---

# Quick Blog - Backend Guidelines

## Express & Node.js Patterns

### Module System
- Use **ES6+ module syntax** (`import/export`)
- Ensure `"type": "module"` is set in `package.json`
- No CommonJS (`require/module.exports`) unless absolutely necessary

### Async/Await Pattern
- Use async/await for all asynchronous operations
- Always wrap in try-catch blocks
- Return appropriate HTTP status codes

```javascript
// Good
const getBlogById = async (req, res) => {
  try {
    const blog = await Blog.findById(req.params.id).populate('comments')
    
    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      })
    }
    
    res.json({ success: true, data: blog })
  } catch (error) {
    console.error('Error fetching blog:', error)
    res.status(500).json({
      success: false,
      message: 'Failed to fetch blog'
    })
  }
}
```

### Controller Best Practices
- Keep controllers thin - extract complex logic to services
- Handle validation at the start of controller functions
- Use early returns for error conditions
- Always return appropriate HTTP status codes

### Middleware Usage
- Use middleware for cross-cutting concerns:
  - Authentication: [middleware/auth.js](mdc:server/src/middleware/auth.js)
  - File uploads: [middleware/multer.js](mdc:server/src/middleware/multer.js)
  - Error handling: [middleware/errorHandler.js](mdc:server/src/middleware/errorHandler.js)
  - Logging: [utils/httpLogger.js](mdc:server/src/utils/httpLogger.js)

## API Design

### RESTful Conventions
- Use plural nouns for resources: `/api/blogs`, `/api/comments`
- Use proper HTTP methods:
  - `GET` - Retrieve resource(s)
  - `POST` - Create new resource
  - `PUT` - Update entire resource
  - `PATCH` - Partial update
  - `DELETE` - Remove resource

### Route Organization
- Prefix admin routes with `/admin`: `/api/admin/add-blog`
- Group related routes in route files: `blogRoutes.js`, `adminRoutes.js`
- Apply middleware at route level when needed

```javascript
// Example route structure
router.get('/blogs', blogController.getBlogs)                    // Public
router.get('/blogs/:id', blogController.getBlogById)             // Public
router.post('/admin/add-blog', authMiddleware, adminController.addBlog)  // Protected
```

### API Response Standards

**Success Response:**
```javascript
res.json({
  success: true,
  data: result
})
```

**Error Response:**
```javascript
res.status(statusCode).json({
  success: false,
  message: 'Error description'
})
```

### Input Validation
- Always validate input data
- Validate at the beginning of controller functions
- Use Mongoose schema validation
- Sanitize user inputs to prevent injection attacks

```javascript
const addBlog = async (req, res) => {
  const { title, content, category } = req.body
  
  // Validation
  if (!title || !content || !category) {
    return res.status(400).json({
      success: false,
      message: 'Title, content, and category are required'
    })
  }
  
  // Continue with business logic...
}
```

## MongoDB & Mongoose

### Schema Definition
- Define schemas with proper validation in [models/](mdc:server/src/models)
- Use descriptive field names
- Set appropriate data types
- Add required fields and default values

```javascript
const blogSchema = new mongoose.Schema({
  title: { type: String, required: true, trim: true },
  content: { type: String, required: true },
  author: { type: String, required: true },
  category: { type: String, required: true },
  image: { type: String },
  published: { type: Boolean, default: false },
  comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Comment' }]
}, { timestamps: true })
```

### Query Optimization
- Use `.lean()` for read-only queries (returns plain objects, faster)
- Define indexes on frequently queried fields
- Use `.populate()` for related documents
- Limit fields returned with `.select()`

```javascript
// Good - optimized query
const blogs = await Blog
  .find({ category: 'tech' })
  .select('title excerpt image createdAt')
  .lean()
  .limit(10)

// When you need to modify documents
const blog = await Blog.findById(id)  // Returns Mongoose document
blog.views += 1
await blog.save()
```

### Indexes
- Create indexes for fields used in queries
- Located in [migrations/](mdc:server/migrations)
- Common indexes: `category`, `createdAt`, `author`

### Transactions
- Use transactions for multi-document operations
- Ensure atomicity for critical operations

```javascript
const session = await mongoose.startSession()
session.startTransaction()

try {
  await Blog.create([newBlog], { session })
  await User.updateOne({ _id: userId }, { $inc: { blogCount: 1 } }, { session })
  await session.commitTransaction()
} catch (error) {
  await session.abortTransaction()
  throw error
} finally {
  session.endSession()
}
```

## Error Handling

### Controller Error Pattern
```javascript
const controllerFunction = async (req, res) => {
  try {
    // Business logic
    res.json({ success: true, data: result })
  } catch (error) {
    console.error('Error in controllerFunction:', error)
    res.status(500).json({
      success: false,
      message: error.message || 'Internal server error'
    })
  }
}
```

### Error Handling Rules
- Use try-catch blocks in all async functions
- Log errors on the server side for debugging
- Return meaningful error messages to the client
- Don't expose sensitive information in error messages
- Use appropriate HTTP status codes

### Common Status Codes
- `200` - Success
- `201` - Created
- `400` - Bad Request (validation errors)
- `401` - Unauthorized (not authenticated)
- `403` - Forbidden (authenticated but not authorized)
- `404` - Not Found
- `500` - Internal Server Error

## Security Best Practices

### JWT Authentication
- Generate JWT tokens with `jwt.sign()`
- Verify tokens in auth middleware with `jwt.verify()`
- Store JWT_SECRET in environment variables
- Set appropriate token expiration

### Input Sanitization
- Validate all user inputs
- Sanitize data before database operations
- Use Mongoose schema validation
- Prevent NoSQL injection

### Environment Variables
- Store sensitive data in `.env` file
- Never commit `.env` to version control
- Required variables:
  - `MONGODB_URI` - Database connection string
  - `JWT_SECRET` - Secret for JWT signing
  - `IMAGEKIT_PUBLIC_KEY`, `IMAGEKIT_PRIVATE_KEY`, `IMAGEKIT_URL_ENDPOINT`
  - `GEMINI_API_KEY` - For AI features
  - `PORT` - Server port (default: 5000)

### CORS Configuration
- Configure CORS to accept requests from client domain
- Set appropriate CORS headers
- Handle preflight requests

## Image Handling

### Upload Flow
1. Multer middleware parses `multipart/form-data`
2. File stored in memory (not disk)
3. Upload to ImageKit CDN via [imageKit.js](mdc:server/src/configs/imageKit.js)
4. Store returned URL in database
5. Client fetches images from ImageKit CDN

```javascript
const uploadImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No file uploaded'
      })
    }

    const result = await imagekit.upload({
      file: req.file.buffer,
      fileName: req.file.originalname
    })

    res.json({
      success: true,
      data: { url: result.url }
    })
  } catch (error) {
    console.error('Upload error:', error)
    res.status(500).json({
      success: false,
      message: 'Failed to upload image'
    })
  }
}
```

### Image Validation
- Validate file types (accept only images)
- Validate file size (limit to reasonable size)
- Handle upload errors gracefully

## Service Layer Pattern

For complex business logic, extract to service layer:

```javascript
// services/blogService.js
export const createBlogWithDefaults = async (blogData) => {
  const processedData = {
    ...blogData,
    slug: generateSlug(blogData.title),
    readTime: calculateReadTime(blogData.content),
    published: false
  }
  
  return await Blog.create(processedData)
}

// controllers/adminController.js
const addBlog = async (req, res) => {
  try {
    const blog = await blogService.createBlogWithDefaults(req.body)
    res.status(201).json({ success: true, data: blog })
  } catch (error) {
    res.status(500).json({ success: false, message: error.message })
  }
}
```

## Database Connection

- Connection handled in [configs/db.js](mdc:server/src/configs/db.js)
- Handle connection errors gracefully
- Log connection status
- Set up connection event listeners

## Testing API Endpoints

### Manual Testing
- Use tools like Postman or Thunder Client
- Test all CRUD operations
- Verify authentication flows
- Test with various input data (valid, invalid, edge cases)
- Check error responses

### What to Test
- Success scenarios
- Validation errors (missing fields, invalid data)
- Authentication/authorization
- Database errors
- Edge cases (empty arrays, null values, etc.)
