---
globs: *.jsx,*.js
description: React and frontend development guidelines for the Quick Blog client application
---

# Quick Blog - React & Frontend Guidelines

## React Component Patterns

### Component Definition
- **Always** use functional components with hooks (no class components)
- Use the `function` keyword for component definitions
- Use `.jsx` extension for all React components

```javascript
// Good
function BlogCard({ title, excerpt, image }) {
  return (
    <div className="blog-card">
      <img src={image} alt={title} />
      <h3>{title}</h3>
      <p>{excerpt}</p>
    </div>
  )
}

// Bad - no class components
class BlogCard extends React.Component {
  render() {
    return <div>...</div>
  }
}
```

### React Hooks Usage

**Core Hooks**: `useState`, `useEffect`, `useContext`, `useReducer`, `useMemo`, `useCallback`

#### Rules of Hooks
- Only call hooks at the **top level** (not inside loops, conditions, or nested functions)
- Only call hooks from React functions (components or custom hooks)
- Custom hooks must start with `use` prefix

#### Performance Hooks
- Use `React.memo()` for component memoization when re-renders are expensive
- Use `useCallback` for memoizing functions passed as props
- Use `useMemo` for expensive computations
- Avoid inline function definitions in render to prevent unnecessary re-renders

```javascript
// Good - memoized callback
const handleSubmit = useCallback((data) => {
  submitForm(data)
}, [submitForm])

// Bad - creates new function on every render
<Button onClick={() => submitForm(data)} />
```

### Component Composition

- Prefer **composition over inheritance**
- Use `children` prop for flexible component structure
- Use render props pattern when needed
- Keep components small and focused (single responsibility)

```javascript
// Good - composition
function BlogLayout({ sidebar, children }) {
  return (
    <div className="blog-layout">
      <aside>{sidebar}</aside>
      <main>{children}</main>
    </div>
  )
}

// Usage
<BlogLayout sidebar={<CategoryFilter />}>
  <BlogGrid blogs={blogs} />
</BlogLayout>
```

### Code Splitting

- Use `React.lazy()` and `Suspense` for route-based code splitting
- Load non-critical components dynamically

```javascript
const AdminDashboard = lazy(() => import('@/pages/admin/Dashboard'))

function App() {
  return (
    <Suspense fallback={<Loader />}>
      <AdminDashboard />
    </Suspense>
  )
}
```

## State Management

### Local State
- Use `useState` for component-level state
- Lift state up when multiple components need to share it
- Keep state as local as possible

### Global State
- Use React Context API via [AppContext.jsx](mdc:client/src/context/AppContext.jsx)
- Store global concerns: user session, JWT tokens, theme
- Avoid prop drilling for deeply nested components

### When to Use Context
- Authentication state
- User preferences
- Global UI state (modals, notifications)
- Shared data needed by many components

## Styling with Tailwind CSS

### Core Principles
- Use Tailwind CSS for **all** styling
- Use utility classes directly in JSX
- **Never** use the `@apply` directive
- **Never** use CSS-in-JS or styled-components

### Responsive Design
- Mobile-first approach
- Use responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`
- Test on multiple screen sizes

### Class Organization
Combine classes logically:
```javascript
<div className="
  flex flex-col gap-4          // Layout
  p-6 mx-auto                  // Spacing
  bg-white rounded-lg shadow   // Visual
  text-gray-900 text-lg        // Typography
">
```

### Tailwind Best Practices
- Leverage Tailwind's spacing scale (`p-4`, `gap-6`, `space-y-8`)
- Use color scales consistently (`gray-100`, `blue-500`)
- Use Tailwind's typography utilities
- Implement dark mode with `dark:` prefix if needed

## Forms & Validation

### Form Pattern
- Use **controlled components** for form inputs
- Handle loading states during submission
- Implement validation (client-side and server-side)
- Use React Hot Toast for user feedback

```javascript
function CommentForm({ blogId, onSuccess }) {
  const [formData, setFormData] = useState({ name: '', comment: '' })
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleSubmit = async (e) => {
    e.preventDefault()
    
    if (!formData.name || !formData.comment) {
      toast.error('Please fill in all fields')
      return
    }

    setIsSubmitting(true)
    try {
      await submitComment(blogId, formData)
      toast.success('Comment submitted!')
      onSuccess()
    } catch (error) {
      toast.error(error.message || 'Failed to submit comment')
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* form fields */}
      <button disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  )
}
```

## Performance Optimization

### Minimize Re-renders
- Use `React.memo()` for expensive components
- Memoize callbacks with `useCallback`
- Memoize computed values with `useMemo`
- Avoid creating objects/arrays in render

### Lazy Loading
- Implement lazy loading for images
- Use dynamic imports for routes
- Load non-critical components after initial render

### Effect Optimization
- Keep `useEffect` dependencies minimal
- Use cleanup functions to prevent memory leaks
- Avoid unnecessary effects

```javascript
// Good - cleanup function
useEffect(() => {
  const subscription = subscribeToUpdates()
  
  return () => {
    subscription.unsubscribe()
  }
}, [])
```

## Error Handling

### Component Level
- Handle errors at the beginning of functions
- Use early returns for error conditions
- Display user-friendly messages with React Hot Toast
- Log errors to console for debugging

### Conditional Rendering
- Use short-circuit evaluation: `{isLoading && <Loader />}`
- Use ternary operators: `{error ? <Error /> : <Content />}`
- Avoid complex nested ternaries

## Refs & DOM Access

- Use refs sparingly - mainly for DOM access
- Common use cases: focus management, measuring elements, third-party DOM libraries
- Prefer declarative approaches over imperative

## Component Structure Example

```javascript
import { useState, useEffect, useCallback } from 'react'
import { toast } from 'react-hot-toast'
import { BlogCard } from '@/components/blog'
import { fetchBlogs } from '@/api/blogApi'

// Main component
function BlogList({ category }) {
  const [blogs, setBlogs] = useState([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState(null)

  const loadBlogs = useCallback(async () => {
    setIsLoading(true)
    setError(null)
    
    try {
      const data = await fetchBlogs({ category })
      setBlogs(data)
    } catch (err) {
      setError(err.message)
      toast.error('Failed to load blogs')
    } finally {
      setIsLoading(false)
    }
  }, [category])

  useEffect(() => {
    loadBlogs()
  }, [loadBlogs])

  if (isLoading) return <LoadingSpinner />
  if (error) return <ErrorMessage message={error} />
  if (blogs.length === 0) return <EmptyState />

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {blogs.map(blog => (
        <BlogCard key={blog._id} {...blog} />
      ))}
    </div>
  )
}

// Subcomponents
function LoadingSpinner() {
  return <div className="flex justify-center p-8">Loading...</div>
}

function ErrorMessage({ message }) {
  return <div className="text-red-600 p-4">{message}</div>
}

function EmptyState() {
  return <div className="text-gray-500 p-8 text-center">No blogs found</div>
}

export { BlogList }
```

## What NOT to Do

❌ Don't use class components
❌ Don't use TypeScript (this is a JavaScript project)
❌ Don't use CSS-in-JS or styled-components
❌ Don't use the `@apply` directive in CSS
❌ Don't ignore error handling
❌ Don't create inline functions in render without memoization
❌ Don't mutate state directly
❌ Don't forget cleanup functions in `useEffect`
